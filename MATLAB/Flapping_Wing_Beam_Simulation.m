%% ========================================================================
% COMPARATIVE SIMULATION — POWER FOR DIFFERENT CONFIGURATIONS
% This script simulates the dynamic response of a cantilever beam model
% and computes the electrical power generated by two groups of panels
% attached along the span, for different flapping amplitudes and frequencies.
%
% Vítor D. Marchiori, Rodrigo B. Santos and Douglas D. Bueno
% =========================================================================
clc; clear; close all;
tic

%% ------------------------------------------------------------------------
% PHYSICAL AND SIMULATION PARAMETERS
% -------------------------------------------------------------------------
E        = 210e9;      % Young's modulus [Pa]
b        = 0.02;       % beam width [m]
h        = 0.005;      % beam thickness [m]
I        = b*h^3/12;   % second moment of area [m^4]
rho      = 7800;       % density [kg/m^3]
A_cross  = b*h;        % cross-sectional area [m^2]
L_total  = 1.0;        % total beam length [m]

ne            = 20;                  % number of finite elements
nn            = ne + 1;              % number of nodes
dofs_per_node = 2;                   % [w, theta] per node
total_dofs    = nn * dofs_per_node;
le            = L_total / ne;        % element length [m]

dts     = 1e-5;       % time step [s]
t_final = 5.0;        % final time [s]
time    = 0:dts:t_final;
Nt      = numel(time);

% Smootherstep ramp function for a smooth transition of motion at the start
T_smooth    = 0.5;    % ramp duration [s]
smootherstep = @(x) (x.^3 .* (x .* (6*x - 15) + 10)) .* (x >= 0 & x <= 1) + (x > 1);

% Sun vector in the inertial (world) reference frame
altitude_sun = deg2rad(47);
azimuth_sun  = deg2rad(0);
n_sun_W = [sin(altitude_sun)*cos(azimuth_sun);
           sin(altitude_sun)*sin(azimuth_sun);
           cos(altitude_sun)];

% Normal irradiance [W/m²]
I_n = 1750 * 0.2778;

% Body orientation (yaw–pitch–roll convention)
yaw   = deg2rad(0);
pitch = deg2rad(10);
roll  = deg2rad(0);

Rx = [1 0 0;
      0 cos(roll) -sin(roll);
      0 sin(roll)  cos(roll)];
Ry = [ cos(pitch) 0 sin(pitch);
       0          1 0;
      -sin(pitch) 0 cos(pitch)];
Rz = [cos(yaw) -sin(yaw) 0;
      sin(yaw)  cos(yaw) 0;
      0         0        1];

R = Rz * Ry * Rx;

% Pre-compute: Sun vector in the body reference frame
% dot(n_sun_W, n_W) = dot(R'*n_sun_W, n_B) => avoids multiplying by R every step
n_sun_B = R' * n_sun_W;
nSB2    = n_sun_B(2);   % y-component in body frame
nSB3    = n_sun_B(3);   % z-component in body frame

% PV panel parameters (generic)
eta    = 0.1705;            % efficiency
A_elem = 0.061 * 0.107;     % area [m²] per element/panel

% Constant: power (mW) per "dot_p" per element
% P_elem = eta * A_elem * (I_n * dot_p) [W] => *1000 [mW]
K_mW = 1000 * eta * A_elem * I_n;

% Additional generic scaling factor (user adjustable)
scale_factor = 0.7;
K_mW = K_mW * scale_factor;

% Panel-group configurations along the span (indices of beam nodes/elements)
% Each row in the cell array represents two groups (group 1 and group 2)
panelGroupConfigs = {
    [5:8, 13:16];
    [3:6, 15:18];
    [13:16, 17:20];
    [1:4, 5:8];
};

% Flapping frequencies (Hz) and amplitudes (degrees -> radians)
f_tests = [1, 2];                 % [Hz]
A_tests = deg2rad([30, 60]);      % [rad]

%% -------------------------------------------------------------------------
% ELEMENT MATRICES AND GLOBAL ASSEMBLY
% -------------------------------------------------------------------------
K_global = zeros(total_dofs);
M_global = zeros(total_dofs);

for e = 1:ne
    dofs = [2*e-1, 2*e, 2*e+1, 2*e+2];

    coeffK = E*I / le^3;
    Ke = coeffK * [  12    6*le   -12    6*le;
                     6*le  4*le^2  -6*le  2*le^2;
                    -12   -6*le    12   -6*le;
                     6*le  2*le^2  -6*le  4*le^2];

    coeffM = rho*A_cross*le / 420;
    Me = coeffM * [156    22*le    54    -13*le;
                   22*le   4*le^2  13*le  -3*le^2;
                    54    13*le   156    -22*le;
                  -13*le  -3*le^2 -22*le  4*le^2];

    K_global(dofs, dofs) = K_global(dofs, dofs) + Ke;
    M_global(dofs, dofs) = M_global(dofs, dofs) + Me;
end

%% -------------------------------------------------------------------------
% DOF REDUCTION (CANTILEVER SUPPORT AT THE ROOT)
% -------------------------------------------------------------------------
% Remove the first global DOF (w1) to impose clamped displacement at the root
K_red = K_global(2:end, 2:end);
M_red = M_global(2:end, 2:end);

% Partitioning: the first remaining DOF is theta1 (prescribed motion)
Mll = M_red(2:end, 2:end);
Kll = K_red(2:end, 2:end);
Mlm = M_red(2:end, 1);
Klm = K_red(2:end, 1);

n       = length(Kll);             % number of free DOFs (w2,theta2,w3,theta3,...)
Z       = zeros(n);
I_nmat  = eye(n);
Minv    = Mll \ eye(n);            % numerically more stable than inv(Mll)

A_mat = [Z,        -Minv*Kll;
         I_nmat,    Z];

% Indices of rotational DOFs within u_free = [w2,theta2,w3,theta3,...]
% free rotations => u_free(2:2:end) ≡ theta2..theta_nn
idx_theta_free = 2:2:n;

%% -------------------------------------------------------------------------
% MAIN LOOP OVER CONFIGURATIONS (PANEL GROUPS, AMPLITUDES, FREQUENCIES)
% -------------------------------------------------------------------------
Fs = 1/dts;  % sampling frequency of the simulated signals

legendLabels = {'Group 1','Group 2'};

for bb = 1:length(panelGroupConfigs)

    groups = panelGroupConfigs{bb};

    % Split into 2 groups (first half and second half)
    midIdx = numel(groups)/2;
    group1 = groups(1:midIdx);
    group2 = groups(midIdx+1:end);

    % Storage for power time histories (for later PSD and spectrogram)
    P1_store  = cell(length(A_tests), length(f_tests));
    P2_store  = cell(length(A_tests), length(f_tests));
    Psum_store = cell(length(A_tests), length(f_tests));

    %% --------------------- FIGURE 1: POWER vs TIME -----------------------
    figure('Name', sprintf('Power (Time) - Panel Groups Configuration %d', bb), ...
           'Color', 'w', 'Position', [100, 100, 1200, 600]);
    tiledlayout(length(A_tests), length(f_tests), 'TileSpacing', 'compact');

    for ai = 1:length(A_tests)
        for fi = 1:length(f_tests)

            A_theta = A_tests(ai);        % flapping amplitude [rad]
            w_theta = 2*pi*f_tests(fi);   % flapping angular frequency [rad/s]

            % State vector: x = [v; u_free] (2n x 1)
            x = zeros(2*n, 1);

            % Pre-allocate histories
            theta1_hist = zeros(Nt, 1);
            P1          = zeros(Nt, 1);
            P2          = zeros(Nt, 1);

            % ---------------- TIME INTEGRATION (RK4) ----------------------
            for it = 1:Nt
                t = time(it);

                % Smootherstep ramp from 0 to 1 over T_smooth
                s_frac = min(t / T_smooth, 1);
                s_val  = smootherstep(s_frac);

                if t < T_smooth
                    x_s   = t / T_smooth;
                    ds_dt   = (30*x_s^2 - 60*x_s^3 + 30*x_s^4) / T_smooth;
                    d2s_dt2 = (60*x_s - 180*x_s^2 + 120*x_s^3) / T_smooth^2;
                else
                    ds_dt   = 0;
                    d2s_dt2 = 0;
                end

                % Prescribed rotation at the root (theta1)
                theta1      = A_theta * sin(w_theta * t) * s_val;
                theta1_ddot = A_theta * ( ...
                               -w_theta^2 * sin(w_theta * t) * s_val ...
                               - 2*w_theta * cos(w_theta * t) * ds_dt ...
                               + sin(w_theta * t) * d2s_dt2 );

                theta1_hist(it) = theta1;

                % Equivalent load vector due to prescribed rotation
                ext = -Mlm * theta1_ddot - Klm * theta1;
                B   = [Minv * ext; zeros(n, 1)];

                % State-space form: x_dot = A_mat * x + B
                f_dyn = @(xi) A_mat * xi + B;

                % Runge–Kutta 4th order
                k1 = f_dyn(x);
                k2 = f_dyn(x + 0.5*dts*k1);
                k3 = f_dyn(x + 0.5*dts*k2);
                k4 = f_dyn(x + dts*k3);
                x  = x + dts*(k1 + 2*k2 + 2*k3 + k4)/6;

                % ---------------------------------------------------------
                % POWER EVALUATION FROM NODAL ROTATIONS
                % ---------------------------------------------------------
                u_free      = x(n+1:end);                  % [w2,theta2,w3,theta3,...]
                theta_nodes = [theta1; u_free(idx_theta_free)];  % [theta1, theta2, ..., theta_nn]

                % Group 1
                th1  = theta_nodes(group1);
                dot1 = -nSB2*sin(th1) + nSB3*cos(th1);     % cosine of incidence relative to sun
                dot1 = max(dot1, 0);                       % no negative contribution
                P1(it) = K_mW * sum(dot1);

                % Group 2
                th2  = theta_nodes(group2);
                dot2 = -nSB2*sin(th2) + nSB3*cos(th2);
                dot2 = max(dot2, 0);
                P2(it) = K_mW * sum(dot2);
            end

            Psum = P1 + P2;

            % Store for spectral analyses
            P1_store{ai, fi}   = P1;
            P2_store{ai, fi}   = P2;
            Psum_store{ai, fi} = Psum;

            % ----------------------------- PLOT: TIME ----------------------
            idx_subplot = (ai - 1) * length(f_tests) + fi;
            ax = nexttile(idx_subplot); hold(ax, 'on');

            idx_letter = (ai - 1) * length(f_tests) + fi;
            letter = char('a' + idx_letter - 1);

            plot(ax, time, P1, 'r',   'LineWidth', 1.5);
            plot(ax, time, P2, 'b--', 'LineWidth', 1.5);

            title(ax, sprintf('(%s) $f=%.1f$ Hz, $A=%d^\\circ$', ...
                letter, f_tests(fi), round(rad2deg(A_theta))), ...
                'Interpreter', 'latex', 'FontSize', 14);

            if fi == 1
                ylabel(ax, 'Power [mW]', 'Interpreter', 'latex', 'FontSize', 14);
            end
            if ai == length(A_tests)
                xlabel(ax, 'Time [s]', 'Interpreter', 'latex', 'FontSize', 14);
            end

            if ai == 1 && fi == length(f_tests)
                legend(ax, legendLabels, 'Location', 'eastoutside', ...
                    'Interpreter', 'latex', 'FontSize', 10);
            end

            grid(ax, 'on'); box(ax, 'on');
            ax.TickLabelInterpreter = 'latex';
            ax.FontSize            = 14;
            ax.XMinorGrid          = 'on';
            ax.YMinorGrid          = 'on';
            ax.GridAlpha           = 0.3;

            % Adjust as needed for your expected power range
            ylim(ax, [0 1300]);
        end
    end

    %% ---------------------------------------------------------------------
    % 2) POWER SPECTRAL DENSITY (PSD, WELCH) OF TOTAL POWER — PER SCENARIO
    % ---------------------------------------------------------------------
    figure('Name', sprintf('PSD (Welch) - Total Power - Panel Groups %d', bb), ...
           'Color', 'w', 'Position', [100, 100, 1200, 600]);
    tiledlayout(length(A_tests), length(f_tests), 'TileSpacing', 'compact');

    for ai = 1:length(A_tests)
        for fi = 1:length(f_tests)
            Psum = Psum_store{ai, fi};

            ax = nexttile; hold(ax, 'on');

            % Welch method (one-sided / centered around zero)
            % Window and overlap can be tuned to balance resolution and noise
            win = 4096;
            if win > numel(Psum), win = floor(numel(Psum)/8); end
            if mod(win,2)==1, win = win-1; end
            if win < 256, win = 256; end
            ovl = round(0.75*win);
            nfft = max(4096, 2^nextpow2(win));

            [pxx, fwelch] = pwelch(Psum - mean(Psum), win, ovl, nfft, Fs, ...
                                   'centered', 'power');

            % Plot as PSD in dB (10*log10)
            plot(fwelch, 10*log10(pxx), 'LineWidth', 1.5);

            % Titles / labels
            A_theta = A_tests(ai);
            idx_letter = (ai - 1) * length(f_tests) + fi;
            letter = char('a' + idx_letter - 1);

            title(ax, sprintf('(%s) $f=%.1f$ Hz, $A=%d^\\circ$', ...
                letter, f_tests(fi), round(rad2deg(A_theta))), ...
                'Interpreter', 'latex', 'FontSize', 14);

            if fi == 1
                ylabel(ax, 'PSD [mW$^2$/Hz]', 'Interpreter', 'latex', 'FontSize', 14);
            end
            if ai == length(A_tests)
                xlabel(ax, 'Frequency [Hz]', 'Interpreter', 'latex', 'FontSize', 14);
            end

            grid(ax, 'on'); box(ax, 'on');
            ax.TickLabelInterpreter = 'latex';
            ax.FontSize            = 14;
            ax.XMinorGrid          = 'on';
            ax.YMinorGrid          = 'on';
            ax.GridAlpha           = 0.3;

            % Optionally limit the frequency axis
            % xlim(ax, [0, Fs/2]);
        end
    end

    %% ---------------------------------------------------------------------
    % 3) SPECTROGRAM OF TOTAL POWER — PER SCENARIO
    % ---------------------------------------------------------------------
    figure('Name', sprintf('Spectrogram - Total Power - Panel Groups %d', bb), ...
           'Color', 'w', 'Position', [100, 100, 1200, 650]);
    tiledlayout(length(A_tests), length(f_tests), 'TileSpacing', 'compact');

    for ai = 1:length(A_tests)
        for fi = 1:length(f_tests)
            Psum = Psum_store{ai, fi};

            ax = nexttile;

            % Spectrogram parameters
            winS = 4096;
            if winS > numel(Psum), winS = floor(numel(Psum)/8); end
            if mod(winS,2)==1, winS = winS-1; end
            if winS < 512, winS = 512; end
            ovlS  = round(0.85*winS);
            nfftS = max(4096, 2^nextpow2(winS));

            % Spectrogram (MATLAB automatically sets time/frequency axes)
            spectrogram(Psum - mean(Psum), winS, ovlS, nfftS, Fs, 'yaxis');
            colormap turbo;

            % Style adjustments
            ax = gca;
            ax.TickLabelInterpreter = 'latex';
            ax.FontSize             = 13;
            ax.GridAlpha            = 0.3;
            grid on; box on;

            % Titles / labels
            A_theta    = A_tests(ai);
            idx_letter = (ai - 1) * length(f_tests) + fi;
            letter     = char('a' + idx_letter - 1);

            title(sprintf('(%s) $f=%.1f$ Hz, $A=%d^\\circ$', ...
                letter, f_tests(fi), round(rad2deg(A_theta))), ...
                'Interpreter', 'latex', 'FontSize', 14);

            if fi == 1
                ylabel('Frequency [kHz]', 'Interpreter', 'latex', 'FontSize', 14);
                % Note: with very high Fs, MATLAB shows the frequency axis in kHz when 'yaxis' is used.
                % If you prefer Hz, remove 'yaxis' and adjust the axis manually.
            end
            if ai == length(A_tests)
                xlabel('Time [s]', 'Interpreter', 'latex', 'FontSize', 14);
            end
        end
    end
end

toc
